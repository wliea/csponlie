1.库名、表名、字段名必须使用小写字母，并采用下划线分割.  命名必须严格遵守“驼峰命名法”
2.其他规范:
  库名、表名、字段名禁止超过32个字符，需见名知意。
  临时库、备份表表名须以标识加日期为后缀。如 _bak20160425
  按日期时间分表须符合_YYYY[MM][DD]格式。

3.适度使用存储过程、视图，禁止使用触发器、事件
      存储过程（procedure）虽然可以简化业务端代码，在传统企业写复杂逻辑时可能会用到，而在互联网企业变更是很频繁的，在分库分表的情况下要升级一个存储过程相当麻烦。又因为它是不记录log的，所以也不方便debug性能问题。如果使用过程，一定考虑如果执行失败的情况。 
      使用视图一定程度上也是为了降低代码里SQL的复杂度，但有时候为了视图的通用性会损失性能（比如返回不必要的字段）。
      触发器（trigger）也是同样，但也不应该通过它去约束数据的强一致性，mysql只支持“基于行的触发”，也就是说，触发器始终是针对一条记录的，而不是针对整个sql语句的，如果变更的数据集非常大的话，效率会很低。掩盖一条sql背后的工作，一旦出现问题将是灾难性的，但又很难快速分析和定位。再者需要ddl时无法使用pt-osc工具。放在transaction执行。
      事件（event）也是一种偷懒的表现，目前已经遇到数次由于定时任务执行失败影响业务的情况，而且mysql无法对它做失败预警。建立专门的 job scheduler 平台。
注意：1.单表数据量控制在5000w以内    2.数据库中不允许存储明文密码
4.字段规范
（1）char、varchar、text等字符串类型定义：
  对于长度基本固定的列，如果该列恰好更新又特别频繁，适合char；
  varchar虽然存储变长字符串，但不可太小也不可太大。UTF8最多能存21844个汉字，或65532个英文；
  TEXT类型与VARCHAR都类似，存储可变长度，最大限制也是2^16，一般用于存放容量平均都很大、操作没有其它字段那样频繁的值。
（2）int、tinyint、decimal等数字类型定义:
  使用tinyint来代enum和boolean，tinyint使用1个字节，一般用status,type,flag的列；int使用固定4个字节存储，int(11)与int(4)只是显示宽度的区别；
  使用Decimal 代替float/double存储精确浮点数对于货币、金额这样的类型，使用decimal，如 decimal(9,2)。float默认只能能精确到6位有效数字。
（3）timestamp与datetime选择:
  datetime 和 timestamp类型所占的存储空间不同，前者8个字节，后者4个字节，这样造成的后果是两者能表示的时间范围不同,TIMESTAMP 支持的范围比 DATATIME 要小;
  timestamp显示与时区有关，内部总是以 UTC 毫秒 来存的。还受到严格模式的限制；
  优先使用timestamp，datetime也没问题；
  where条件里不要对时间列上使用时间函数；
（4）建议字段都定义为NOT NULL:
  如果是索引字段，一定要定义为not null 。
  因为null值会影响cordinate统计，影响
  优化器对索引的选择;
  如果不能保证insert时一定有值过来，定义时使用default ‘’，或 0。
（5）同一意义的字段定义必须相同:
  比如不同表中都有 f_user_id 字段，那么它的类型、字段长度要设计成一样。
5.索引规范
  5.1
  任何新的select,update,delete上线，都要先explain，看索引使用情况。
  索引个数限制。
  避免冗余索引。
  没有特殊要求，使用自增id作为主键。
  索引尽量建在选择性高的列上。
  最左前缀原则。
  合理使用覆盖索引减少IO。
  尽量不要在频繁更新的列上创建索引。
  5.2 Explain解读说明
  Type（访问类型）：ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）。
  possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。
  key：表示MySQL实际决定使用的键（索引）如果没有选择索引，键是NULL。
  ref：表示选择 key 列上的索引，哪些列或常量被用于查找索引列上的值。
  rows：根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数。
  Extra 
  Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。
  Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”。
  5.3
  索引个数限制
     索引是双刃剑，会增加维护负担，增大IO压力，索引占用空间是成倍增加的单张表的索引数量控制在5个以内，或不超过表字段个数的20%。若单张表多个字段在查询需求上都要单独用到索引，需要经过DBA评估。
  避免冗余索引
     InnoDB表是一棵索引组织表，主键是和数据放在一起的聚集索引，普通索引最终指向的是主键地址，所以把主键做最后一列是多余的。如f_crm_id作为主键，联合索引(f_user_id,f_crm_id)上的f_crm_id就完全多余(a,b,c)、(a,b)，后者为冗余索引。
     可以利用前缀索引来达到加速目的，减轻维护负担
  没有特殊要求，使用自增id作为主键
     主键是一种聚集索引，顺序写入。组合唯一索引作为主键的话，是随机写入，适合写少读多的表主键不允许更新.
  索引尽量建在选择性高的列上
     不在低基数列上建立索引，例如性别、类型。走索引扫描行数超过30%时，改全表扫描。
  最左前缀原则
      mysql使用联合索引时，从左向右匹配，遇到断开或者范围查询时，无法用到后续的索引列,比如索引idx_c1_c2_c3 (c1,c2,c3)，相当于创建了(c1)、(c1,c2)、(c1,c2,c3)三个索引，where条件包含上面三种情况的字段比较则可以用到索引，但像 where c1=a and c3=c 只能用到c1列的索引，像 c2=b and c3=c等情况就完全用不到这个索引,遇到范围查询(>、<、between、like)也会停止索引匹配，比如 c1=a and c2 > 2 and c3=c，只有c1,c2列上的比较能用到索引，(c1,c2,c3)排列的索引才可能会都用上where条件里面字段的顺序与索引顺序无关，mysql优化器会自动调整顺序。
  前缀索引
      对超过30个字符长度的列创建索引时，考虑使用前缀索引，如 idx_cs_guid2 (f_cs_guid(26))表示截取前26个字符做索引，既可以提高查找效率，也可以节省空间。
      前缀索引也有它的缺点是，如果在该列上 ORDER BY 或 GROUP BY 时无法使用索引，也不能把它们用作覆盖索(Covering Index)，如果在varbinary或blob这种以二进制存储的列上建立前缀索引，要考虑字符集，括号里表示的是字节数。
  合理使用覆盖索引减少IO
      INNODB存储引擎中，secondaryindex(非主键索引，又称为辅助索引、二级索引)没有直接存储行地址，而是存储主键值。如果用户需要查询secondary index中所不包含的数据列，则需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。覆盖索引则可以在一个索引中获取所有需要的数据列，从而避免回表进行二次查找，节省IO因此效率较高。例如SELECT email，uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid，email)，以获得性能提升。
  尽量不要在频繁更新的列上创建索引
      维护成本太高（好在mysql有insert buffer（缓冲池），会合并索引的插入）。
  6. Sql设计规范
    1.  杜绝直接 SELECT * 读取全部字段。
    2.  能确定返回结果只有一条时，使用 limit 1。
    3.  小心隐式类型转换。
    4.  禁止在where条件列上使用函数。
    5.  使用like模糊匹配，%不要放首位。
    6.  涉及到复杂sql时，务必先参考已有索引设计，先explain。
    7.  使用join时，where条件尽量使用充分利用同一表上的索引。
    8.  少用子查询，改用join。
    9.  考虑使用union all，少使用union，注意考虑去重。
    10.  IN的内容尽量不超过200个。
    11.  拒绝大事务，严重影响MySQL并发能力。
    12.  避免使用is null, is not null这样的比较。
    13.  使用order by .. Limit。
    14.  分页优化。
    15.  count计数。
    16.  delete,update语句改成select再explain。
    17.  减少与数据库交互的次数，尽量采用批量SQL语句。
    18.  杜绝危险SQL。
  7.隐式类型转换规则
  a. 两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 <=> 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换。
  b. 两个参数都是字符串，会按照字符串来比较，不做类型转换。
  c. 两个参数都是整数，按照整数来比较，不做类型转换。
  d. 十六进制的值和非数字做比较时，会被当做二进制串。
  e. 有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp。
  f. 有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较。
  g. 所有其他情况下，两个参数都会被转换为浮点数再进行比较。如果一个索引建立在string类型上，如果这个字段和一个int类型的值比较，符合第 g 条。如f_phone定义的类型是varchar，但where使用f_phone in (098890)，两个参数都会被当成成浮点型。发生这个隐式转换并不是最糟的，最糟的是string转换后的float，mysql无法使用索引，这才导致了性能问题。如果是 f_user_id = ‘1234567’ 的情况，符合第 b 条,直接把数字当字符串比较。











